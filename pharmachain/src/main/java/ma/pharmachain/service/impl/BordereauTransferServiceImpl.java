package ma.pharmachain.service.impl;

import lombok.RequiredArgsConstructor;
import ma.pharmachain.exception.ResourceNotFoundException;
import ma.pharmachain.dto.TransferCreateRequest;
import ma.pharmachain.dto.TransferUpdateRequest;
import ma.pharmachain.entity.Bordereau;
import ma.pharmachain.entity.BordereauTransfer;
import ma.pharmachain.entity.Driver;
import ma.pharmachain.enums.TransferStatus;
import ma.pharmachain.repository.BordereauRepository;
import ma.pharmachain.repository.BordereauTransferRepository;
import ma.pharmachain.repository.DriverRepository;
import ma.pharmachain.service.BordereauTransferService;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;

@Service
@RequiredArgsConstructor
@Transactional
public class BordereauTransferServiceImpl implements BordereauTransferService {

    private final BordereauTransferRepository transferRepository;
    private final BordereauRepository bordereauxRepository;
    private final DriverRepository driverRepository;

    @Override
    public BordereauTransfer createTransfer(String bordereauNumber, TransferCreateRequest request) {
        // Find bordereau
        Bordereau bordereau = bordereauxRepository.findByBordereauNumber(bordereauNumber)
                .orElseThrow(() -> new ResourceNotFoundException("Bordereau not found: " + bordereauNumber));

        // Find fromDriver (current driver of bordereau)
        Driver fromDriver = bordereau.getCurrentDriver();
        if (fromDriver == null) {
            throw new IllegalStateException("Bordereau has no current driver");
        }

        // Find toDriver
        Driver toDriver = driverRepository.findByCode(request.getToDriverCode())
                .orElseThrow(() -> new ResourceNotFoundException("Driver not found: " + request.getToDriverCode()));

        // Validate: cannot transfer to the same driver
        if (fromDriver.getCode().equals(toDriver.getCode())) {
            throw new IllegalArgumentException("Cannot transfer to the same driver");
        }

        // Create transfer with PENDING status
        BordereauTransfer transfer = new BordereauTransfer();
        transfer.setBordereau(bordereau);
        transfer.setFromDriver(fromDriver);
        transfer.setToDriver(toDriver);
        transfer.setReason(request.getReason());
        transfer.setTransferBarcode(request.getTransferBarcode()); // Generated by mobile
        transfer.setTransferredAt(LocalDateTime.now());
        transfer.setStatus(TransferStatus.PENDING); // Start as PENDING

        // Save transfer - DO NOT update bordereau's driver yet
        // Driver will be updated only when status changes to ACCEPTED
        return transferRepository.save(transfer);
    }

    @Override
    @Transactional(readOnly = true)
    public Page<BordereauTransfer> listTransfers(int page, int size) {
        return transferRepository.findAll(
                PageRequest.of(page, size, Sort.by("transferredAt").descending())
        );
    }

    @Override
    @Transactional(readOnly = true)
    public BordereauTransfer getTransferById(Long id) {
        return transferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Transfer not found: " + id));
    }

    @Override
    public BordereauTransfer updateTransfer(Long id, TransferUpdateRequest request) {
        BordereauTransfer transfer = getTransferById(id);

        // Only allow updates if transfer is still PENDING
        if (transfer.getStatus() != TransferStatus.PENDING) {
            throw new IllegalStateException("Cannot update transfer that is not PENDING. Current status: " + transfer.getStatus());
        }

        // Update mutable fields
        if (request.getReason() != null) {
            transfer.setReason(request.getReason());
        }
        if (request.getTransferBarcode() != null) {
            transfer.setTransferBarcode(request.getTransferBarcode());
        }

        return transferRepository.save(transfer);
    }

    @Override
    public BordereauTransfer updateTransferStatus(Long id, TransferStatus status) {
        BordereauTransfer transfer = getTransferById(id);

        // Validate: Cannot change status if already ACCEPTED or REJECTED (final states)
        if (transfer.getStatus() == TransferStatus.ACCEPTED ||
                transfer.getStatus() == TransferStatus.REJECTED) {
            throw new IllegalStateException(
                    "Cannot update status of finalized transfer. Current status: " + transfer.getStatus()
            );
        }

        // Validate: Can only change from PENDING to ACCEPTED or REJECTED
        if (transfer.getStatus() != TransferStatus.PENDING) {
            throw new IllegalStateException(
                    "Can only update status from PENDING. Current status: " + transfer.getStatus()
            );
        }

        // Validate: New status must be ACCEPTED or REJECTED (cannot stay PENDING)
        if (status == TransferStatus.PENDING) {
            throw new IllegalArgumentException("Cannot set status back to PENDING");
        }

        Bordereau bordereau = transfer.getBordereau();

        // Handle status transitions
        if (status == TransferStatus.ACCEPTED) {
            // ACCEPTED: Transfer the bordereau to the new driver
            bordereau.setCurrentDriver(transfer.getToDriver());
            bordereauxRepository.save(bordereau);

        } else if (status == TransferStatus.REJECTED) {
            // REJECTED: Keep the bordereau with the original driver (no change needed)
            // The bordereau's currentDriver should still be fromDriver
            // Optionally verify this:
            if (!bordereau.getCurrentDriver().getCode().equals(transfer.getFromDriver().getCode())) {
                // If somehow the driver was changed, revert it
                bordereau.setCurrentDriver(transfer.getFromDriver());
                bordereauxRepository.save(bordereau);
            }
        }

        // Update transfer status
        transfer.setStatus(status);
        return transferRepository.save(transfer);
    }

    @Override
    public void deleteTransfer(Long id) {
        BordereauTransfer transfer = transferRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Transfer not found: " + id));

        // Only allow deletion of PENDING or REJECTED transfers
        if (transfer.getStatus() == TransferStatus.ACCEPTED) {
            throw new IllegalStateException("Cannot delete an ACCEPTED transfer");
        }

        transferRepository.deleteById(id);
    }
}
